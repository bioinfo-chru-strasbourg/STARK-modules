import csv

def get_sample_info(sample_list):
	sample = {}
	for sample_info in sample_list:
		sample_name = sample_info["name"]
		sample[sample_name] = {}
		sample[sample_name]["bam"] = sample_info["bam"]
		sample[sample_name]["sex"] = sample_info["sex"]
	return sample

def get_sex_list(sample_list,target_sex):
	real_sex_list = []
	if "A" in target_sex:
		real_sex_list.append("A")
	for sample_info in sample_list:
		sex = sample_info["sex"]
		if sex not in real_sex_list and sex in target_sex:
			real_sex_list.append(sample_info["sex"])
	return real_sex_list

def get_window(config):
	if "window" in config["analysis"]:
		return config["analysis"]["window"]
	else:
		return False

output = config["analysis"]["output"]
log = output + "/logs"
sampledict = get_sample_info(config["analysis"]["sample"])
samplelist = sampledict.keys()
sex_list = get_sex_list(config["analysis"]["sample"],config["analysis"]["type"])
scriptdir = os.path.dirname(os.path.realpath(__file__))
window = get_window(config)


rule all:
	input:
		output+"/CANOES/all.canoes.annotsv.tsv"
	output:
		output+"/CANOES/all.canoes.annotsv.sorted.tsv"
	shell:
		"""
			(head -n 1 {input} && tail -n +2 {input} | sort -k2,2n -k3,3n) > {output}
		"""

rule merge_CNVs:
	input:
		expand(output+"/{sample}/CANOES/{sample}.canoes.annotsv.tsv", sample=samplelist),
	output:
		temp(output+"/CANOES/all.canoes.annotsv.tsv")
	run:
		with open(output[0], "w") as o:
			print_header = True
			for file in input:
				ok_header = False
				with open(file, "r") as i:
					for line in i:
						if not ok_header:
							if line.startswith("AnnotSV ID"):
								ok_header = True
								if print_header:
									print_header = False
									o.write(line)
						else:
							o.write(line)


rule bed_to_AnnotSV_annotated:
	params:
		annotsv  = config["tools"]["annotsv"],
		bedtools = config["tools"]["bedtools"]
	input:
		output+"/{sample}/CANOES/{sample}.canoes.bed"
	output:
		results = output+"/{sample}/CANOES/{sample}.canoes.annotsv.tsv",
		tmpe    = temp(output+"/{sample}/CANOES/{sample}.canoes.annotsv.tsve"),
		tmp     = temp(output+"/{sample}/CANOES/{sample}.canoes.formatted.sorted.bed")
	log:
		log+"/{sample}.canoes.annotsv.log"
	shell:
		"""
			export ANNOTSV={params.annotsv}
			$ANNOTSV/bin/AnnotSV -SVinputFile {input} -outputFile {output.results} -svtBEDcol 4 -bedtools {params.bedtools}/bedtools > {log} && [[ -s {output.results} ]] || echo "No data to annotate" > {output.results}
			sed -ie '1s/\t\t/\tSample name\t/' {output.results}
			[[ -f {output.tmp} ]] || touch {output.tmp}
		"""

rule bed_to_sample_bed:
	input:
		output+"/CANOES/canoes.bed"
	output:
		temp(output+"/{sample}/CANOES/{sample}.canoes.bed")
	shell:
		"""
			grep -w "{wildcards.sample}" {input} > {output} && [[ -s {output} ]] || echo "No CNV found" > {output}
		"""

rule canoes_to_bed:
	input:
		output+"/CANOES/canoes.tsv"
	output:
		temp(output+"/CANOES/canoes.bed")
	run:
		with open(output[0], "w") as o:
			o.write("\t".join([ "chrom", "start", "end", "cnv type", "sample name" ])+"\n")
			with open(input[0], "r") as i:
				for line in i:
					if line.startswith("no CNV found"):
						o.write(line)
						break
					elif line.startswith("error in the analysis"):
						o.write(line)
						break
					else:
						field = line.strip().split("\t")
						chrom = field[2].split(":")[0]
						if chrom == "23":
							chrom = "X"
						if chrom == "24":
							chrom = "Y"
						start = field[2].split(":")[1].split("-")[0]
						end = field[2].split(":")[1].split("-")[1]
						sample = field[0]
						cnv = field[1]
						o.write("\t".join([ chrom, start, end, cnv, sample ])+"\n")

if config["tools"]["canoes_version"] == "1":
	rule merge_sex_v1:
		input:
			expand(output+"/CANOES/canoes.{sex}.tsv", sex=sex_list)
		output:
			temp(output+"/CANOES/canoes.tsv")
		shell:
			"""
				cat {input} | sort -u >> {output}
			"""
elif config["tools"]["canoes_version"] == "2":
	rule merge_sex_v2:
		input:
			expand(output+"/CANOES/canoes.{sex}.tsv", sex=sex_list)
		output:
			temp(output+"/CANOES/canoes.tsv")
		shell:
			"""
				cat {input} | awk '{{print $2"\t"$3"\t"$1"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8"\t"$9"\t"$10}}' | sort -u >> {output}
			"""
else:
	print("ERROR - version: "+["tools"]["canoes_version"]+" not available (--version=1 OR --version=2)",file=sys.stderr)
	sys.exit()

if window:
	rule get_bed_window:
		params:
			window = window
		input:
			config["analysis"]["bed"]
		output:
			output+"/CANOES/analysis.bed"
		run:
			bed = []
			with open(input[0],"r") as infile:
				for line in infile:
					field = line.strip().split("\t")
					chrom = field[0]
					start = int(field[1])
					end   = int(field[2])
					info  = field[3:]
					region_len = end-start
					window=params.window
					nb_region  = region_len//int(window)
					region_size = []
					for i in range(nb_region):
						region_size.append(window)
					pos = 0
					reste = region_len-(window*nb_region)
					for i in range(reste):
						if pos >= nb_region:
							pos = 0
						region_size[pos] += 1
						pos +=1
					size = 0
					new_region=[]
					for region in region_size:
						region_start=start+size
						region_end = start+region+size-1
						size+=region
						new_region.append([region_start,region_end])
					new_region[-1][-1]=new_region[-1][-1]+1
					for region in new_region:
						bed.append("\t".join([chrom]+[ str(x) for x in region ]+info))

			with open(output[0],"w") as outfile:
				outfile.write("\n".join(bed))
else:
	rule get_bed:
		input:
			config["analysis"]["bed"]
		output:
			output+"/CANOES/analysis.bed"
		shell:
			"""
				cp {input} {output}
			"""

rule bam_to_multicov:
	params:
		bedtools = config["tools"]["bedtools"]
	input:
		bam = lambda wildcards: sampledict[wildcards.sample]["bam"],
		bed = output+"/CANOES/analysis.bed"
	log:
		log+"/{sample}.multicov.log"
	output:
		output+"/{sample}/CANOES/{sample}.multicov.tsv"
	shell:
		"""
			{params.bedtools}/bedtools multicov -bams {input.bam} -bed {input.bed} -q 20 > {output} 2> {log}
		"""

rule bam_to_gc_percent:
        params:
                gatk = config["tools"]["gatk"],
                java = config["tools"]["java"]
        input:
                bed    = output+"/CANOES/analysis.bed",
                genome = config["analysis"]["genome"]
        log:
                log+"/GCpercent_to_change.log"
        output:
                temp(output+"/CANOES/GCpercent_to_change.tsv")
        shell:
                """
                        {params.java} -Xmx2000m -jar {params.gatk} AnnotateIntervals -L {input.bed} -R {input.genome} -imr OVERLAPPING_ONLY -O {output} &> {log}
                """

rule correct_gc_percent_file:
        input:
                output+"/CANOES/GCpercent_to_change.tsv",
        log:
                log+"/GCpercent.log"
        output:
                temp(output+"/CANOES/GCpercent.tsv")
        shell:
                """
                        cat {input} | awk 'NR>27{{print $0}}' > {output}
                """

rule sex_gc_percent:
	input:
		output+"/CANOES/GCpercent.tsv"
	output:
		temp(output+"/CANOES/GCpercent.{sex}.tsv")
	log:
		log+"/GCpercent.{sex}.log"
	shell:
		"""
			if [[ "{wildcards.sex}" == "A" ]]; then
				grep -vE '^chrX|^chrY' {input} > {output};
			else
				cp {input} {output};
			fi;
		"""

rule merge_multicov_to_reads:
	input:
		expand(output+"/{sample}/CANOES/{sample}.multicov.tsv", sample=samplelist)
	output:
		output+"/CANOES/all.canoes.coverage.unsorted.tsv"
	log:
		log+"/all.canoes.coverage.unsorted.log"
	run:
		data = {}
		header = ["chrom","start","end"]
		for multicovfile in input:
			sample_name = multicovfile.split("/")[-1].split(".")[0]
			header.append(sample_name)
			with open(multicovfile,"r") as i:
				for line in i:
					field = line.strip().split("\t")
					index = "\t".join(field[0:3])
					value = field[-1]
					if index not in data:
						data[index] = {}
					data[index][sample_name] = value

		with open(output[0],"w") as o:
			o.write("\t".join(header)+"\n")
			for index in data:
				sample_value = [index]
				for sample_name in header[3:]:
					sample_value.append(data[index][sample_name])
				o.write("\t".join(sample_value)+"\n")

rule sex_analysis_reads:
	params:
		data = sampledict
	input:
		output+"/CANOES/all.canoes.coverage.tsv"
	output:
		output+"/CANOES/all.canoes.{sex}.coverage.tsv"
	run:
		sample_sex = []
		with open(output[0], "w") as f:
			for sample in params.data:
				if wildcards.sex == "A":
					sample_sex.append(sample)
				else:
					if params.data[sample]["sex"] == wildcards.sex:
						sample_sex.append(sample)

			fieldnames = ['chrom','start','end'] + sample_sex
			f.write("\t".join(fieldnames)+"\n")
			with open(input[0], "r") as tsvfile:
				reader = csv.DictReader(tsvfile, delimiter='\t')
				for row in reader:
					line = [ row[x] for x in fieldnames ]
					if wildcards.sex == "A":
						if line[0] == "chrX" or line[0] == "chrY":
							continue
					f.write("\t".join(line)+"\n")


rule sorted_multicov:
	input:
		"{w}.coverage.unsorted.tsv"
	output:
		"{w}.coverage.tsv"
	shell:
		"""
			head -1 {input} > {output} && sed 1d {input} | sort -k1,1V -k2,2n >> {output}
		"""

rule convert_chr:
	input:
		"{w}"
	output:
		"{w}.conv"
	shell:
		"""
			sed -e "s/^chrX/chr23/" {input} | sed -e "s/^chrY/chr24/" > {output}
		"""

rule without_header:
	input:
		"{w}"
	output:
		temp("{w}.no_header")
	shell:
		"""
			sed '1d' {input} > {output}
		""" 

rule write_R_script:
	params:
		canoes = config["tools"]["canoes"]+"/CANOES.v"+config["tools"]["canoes_version"]+".R",
		output = config["analysis"]["output"]
	input:
		read   = output+"/CANOES/all.canoes.{sex}.coverage.tsv.conv.no_header",
		header = output+"/CANOES/all.canoes.{sex}.coverage.tsv.conv",
		gc     = output+"/CANOES/GCpercent.{sex}.tsv.conv",
	output:
		temp(output+"/CANOES/script_create.{sex}.R")
	run:
		with open(input.header, "r") as f:
			sample_list = ",".join([ "\""+x+"\"" for x in f.read().split('\n')[0].split("\t") ][3:] )

		with open(output[0], "w") as f:
			f.write("setwd(\""+ params.output +"\")\n")
			f.write("gc <- read.table(\""+ input.gc +"\")$V2\n")
			f.write("canoes.reads <- read.table(\""+ input.read +"\")\n")
			f.write("sample.names <- c("+ sample_list +")\n")
			f.write("names(canoes.reads) <- c(\"chromosome\", \"start\", \"end\", sample.names)\n")
			f.write("target <- seq(1, nrow(canoes.reads))\n")
			f.write("canoes.reads <- cbind(target, gc, canoes.reads)\n")
			f.write("source(\""+ params.canoes +"\")\n")
			f.write("xcnv.list <- vector('list', length(sample.names))\n")
			f.write("for (i in 1:length(sample.names)){\n")
			f.write("xcnv.list[[i]] <- CallCNVs(sample.names[i], canoes.reads)\n")
			f.write("}\n")
			f.write("xcnvs <- do.call('rbind', xcnv.list)\n")
			f.write("write.csv(xcnvs, \""+ params.output +"/CANOES/results."+ wildcards.sex +".csv\", row.names=FALSE)\n")

rule canoes_calling:
	params:
		R       = config["tools"]["R"],
		output  = config["analysis"]["output"]
	input:
		read    = output+"/CANOES/all.canoes.{sex}.coverage.tsv.conv.no_header",
		gc      = output+"/CANOES/GCpercent.{sex}.tsv.conv",
		script  = output+"/CANOES/script_create.{sex}.R"
	output:
		results = temp(output+"/CANOES/canoes.{sex}.tsv"),
		tmp     = temp(output+"/CANOES/results.{sex}.csv"),
	log:
		log+"/canoes.{sex}.log"
	shell:
		"""
			{params.R} CMD BATCH {input.script} {log};
			[[ -s {output.tmp} ]] && cat {output.tmp} | sed 's/"//g' | sed 's/,/\t/g' | sed '1d' | sort -u > {output.results} || echo "no CNV found for sex: {wildcards.sex}" > {output.results};
		"""
